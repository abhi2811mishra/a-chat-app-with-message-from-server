// lib/main.dart
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Import our Firebase options file (will be generated by FlutterFire CLI)
import 'firebase_options.dart';

// --- GLOBAL VARIABLES & TOP-LEVEL FUNCTIONS ---

// For local notifications
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

// Background message handler (MUST be a top-level function)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  print('Handling a background message: ${message.messageId}');

  // This is where you'd process the background message and show a notification
  // For incoming call, you'd trigger a local notification from here.
  // We will implement the actual display logic in a separate helper function.
  if (message.data['type'] == 'call') {
    String callerName = message.data['callerName'] ?? 'Unknown Caller';
    String callType = message.data['callType'] ?? 'Incoming Call';
    String callId = message.data['callId'] ?? 'no_call_id';
    print('Received background call notification for ID: $callId from $callerName ($callType)');

    // Display the local notification for the call
    await NotificationService.showCallNotification(
      id: callId.hashCode, // Use a unique ID for the notification
      callerName: callerName,
      callType: callType,
      callId: callId,
    );
  }
}

// --- MAIN FUNCTION ---

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Set up background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize Flutter Local Notifications Plugin
  await NotificationService.initializeNotifications();

  runApp(const MyApp());
}

// --- NOTIFICATION SERVICE CLASS ---
// This class will encapsulate our notification logic for clarity

// lib/main.dart (within NotificationService class)

// lib/main.dart (within NotificationService class)

class NotificationService {
  static Future<void> initializeNotifications() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher'); // Your app icon

    const DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings(
      requestAlertPermission: false, // We'll request in FirebaseMessaging
      requestBadgePermission: false,
      requestSoundPermission: false,
    );

    const InitializationSettings initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsIOS,
    );

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: onDidReceiveNotificationResponse,
      onDidReceiveBackgroundNotificationResponse: onDidReceiveNotificationResponse,
    );

    // Create notification channel for Android (required for Android 8.0+)
    await createNotificationChannel();
  }

  // Handle notification tap (when app is in foreground, background, or terminated)
  static void onDidReceiveNotificationResponse(NotificationResponse response) {
    if (response.payload != null) {
      debugPrint('notification payload: ${response.payload}');
      // Deep linking logic based on payload
      final Uri uri = Uri.parse(response.payload!);
      if (uri.pathSegments.contains('call')) {
        String? callId = uri.queryParameters['callId'];
        if (callId != null) {
          // Navigate to a specific screen based on callId
          // The context for navigation might not be available directly here
          // You might need a global navigator key or use GoRouter's context directly
          // For simplicity, we'll use an alert for now.
          print('Notification tapped: Navigating to call screen for $callId');
          // Example: MyApp.navigatorKey.currentState?.context.go('/call_screen/$callId');
        }
      }
    }
  }


  static Future<void> createNotificationChannel() async {
    // High-priority channel for call notifications
    final AndroidNotificationChannel callChannel = AndroidNotificationChannel(
      'call_channel', // id
      'Incoming Calls', // name
      description: 'Notifications for incoming calls.', // description
      importance: Importance.max, // High importance for heads-up notifications
      playSound: true,
      sound: const RawResourceAndroidNotificationSound('ringtone'), // Custom ringtone (e.g., ringtone.mp3 in android/app/src/main/res/raw)
      enableVibration: true,
      vibrationPattern: Int64List.fromList(const [0, 1000, 500, 1000]), // Vibrate for 1s, pause 0.5s, vibrate 1s
      showBadge: true, // Show badge count
      // For call-like UI on Android 10+
      
    );

    // Default channel for general notifications
    const AndroidNotificationChannel defaultChannel = AndroidNotificationChannel(
      'default_channel', // id
      'General Notifications', // name
      description: 'Notifications for general app updates.', // description
      importance: Importance.defaultImportance,
      showBadge: true,
    );

    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(callChannel);

    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(defaultChannel);
  }

  // Method to display a simple text notification
  static Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'default_channel', // Must match one of your created channels
      'General Notifications',
      channelDescription: 'Notifications for general app updates.',
      importance: Importance.defaultImportance,
      priority: Priority.defaultPriority,
      showWhen: false,
      ticker: 'ticker',
    );
    const DarwinNotificationDetails iOSPlatformChannelSpecifics =
        DarwinNotificationDetails();
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );
    await flutterLocalNotificationsPlugin.show(
      id,
      title,
      body,
      platformChannelSpecifics,
      payload: payload,
    );
  }

  // Method to display an incoming call-like notification
  static Future<void> showCallNotification({
    required int id,
    required String callerName,
    required String callType,
    required String callId,
  }) async {
    // For Android, ensure you have a drawable for the large icon
    // e.g., 'caller_avatar' in `android/app/src/main/res/drawable/`
    // You might also need a small icon for the status bar (e.g., `ic_launcher_round`)

    final AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'call_channel', // Must match your 'call_channel' ID
      'Incoming Calls',
      channelDescription: 'Notifications for incoming calls.',
      importance: Importance.max, // Max importance for heads-up
      priority: Priority.max, // Max priority
      fullScreenIntent: true, // Crucial for showing notification on lock screen (Android 10+)
      // sound: RawResourceAndroidNotificationSound('ringtone'), // Already set in channel
      category: AndroidNotificationCategory.call, // Helps Android understand it's a call
      ongoing: true, // Makes it persistent
      autoCancel: false, // Prevents notification from disappearing on tap
      // custom layout if needed
      // To simulate call buttons (answer/decline) you'd need to use `actionButtons`
      // or a custom `BigPictureStyle`/`MediaStyle` for more complex layouts
      // Example for custom layout: `styleInformation: MediaStyleInformation()`.
      // For true WhatsApp-like call screen when app is killed, the fullScreenIntent
      // combined with a high-priority notification and specific activity flags is key.
      // ignore: deprecated_member_use
      color: Color(Colors.green.value), // Example color for the notification
      ticker: 'Incoming $callType from $callerName',
      largeIcon: const DrawableResourceAndroidBitmap('caller_avatar'), // Add `caller_avatar.png` to `android/app/src/main/res/drawable/`
      
    );

    const DarwinNotificationDetails iOSPlatformChannelSpecifics =
        DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
      // For iOS, you typically play a sound directly using `AudioServicesPlaySystemSound`
      // or similar native code when the app is in the background/terminated.
      // Or you can configure push notifications to play a sound via APNs payload.
      interruptionLevel: InterruptionLevel.critical, // For critical alerts (iOS 12+)
    );

    final NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );

    await flutterLocalNotificationsPlugin.show(
      id,
      callerName, // Title
      'Incoming $callType', // Body
      platformChannelSpecifics,
      payload: 'app://call?callId=$callId&callerName=$callerName', // Deep linking payload
    );
  }

  // Increment and get badge count
  static Future<int> incrementAndGetBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    int count = (prefs.getInt('badge_count') ?? 0) + 1;
    await prefs.setInt('badge_count', count);
    // Corrected line for Android
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(count); 
    // Corrected line for iOS - THIS WAS MISSING
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(count); 
    return count; // THIS RETURN STATEMENT WAS MISSING
  }

  // Clear badge count
  static Future<void> clearBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('badge_count', 0);
    // Corrected line for Android
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(0); 
    // Corrected line for iOS - THIS WAS MISSING
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(0); 
  }
}

extension on IOSFlutterLocalNotificationsPlugin? {
  void setAppBadgeCount(int i) {}
}

extension on AndroidFlutterLocalNotificationsPlugin? {
  void setAppBadgeCount(int i) {}
}



// --- APP WIDGETS ---

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  // Global key for navigation if you're not using GoRouter for simplicity
  // static final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _fcmToken;
  String _notificationStatus = 'Initializing...';
  int _badgeCount = 0;

  final GoRouter _router = GoRouter(
    initialLocation: '/',
    routes: [
      GoRoute(
        path: '/',
        builder: (context, state) => HomePage(
          fcmToken: null,
          notificationStatus: 'Initializing...',
          badgeCount: 0,
          onClearBadge: () {},
        ),
      ),
      GoRoute(
        path: '/call',
        builder: (context, state) {
          final callId = state.uri.queryParameters['callId'];
          final callerName = state.uri.queryParameters['callerName'];
          return CallScreen(callId: callId, callerName: callerName);
        },
      ),
      GoRoute(
        path: '/notification_history',
        builder: (context, state) => const NotificationHistoryScreen(),
      ),
    ],
  );

  @override
  void initState() {
    super.initState();
    _initializeFirebaseMessaging();
    _loadBadgeCount();
  }

  Future<void> _loadBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _badgeCount = prefs.getInt('badge_count') ?? 0;
    });
  }

  void _initializeFirebaseMessaging() async {
    // Request permissions (iOS and Android 13+)
    NotificationSettings settings = await FirebaseMessaging.instance.requestPermission(
      alert: true,
      announcement: true,
      badge: true,
      carPlay: false,
      criticalAlert: true, // For iOS 12+ critical alerts
      provisional: false,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      setState(() => _notificationStatus = 'Authorized');
      print('User granted permission');
    } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
      setState(() => _notificationStatus = 'Provisional');
      print('User granted provisional permission');
    } else {
      setState(() => _notificationStatus = 'Denied');
      print('User declined or has not accepted permission');
    }

    // Get FCM Token
    String? token = await FirebaseMessaging.instance.getToken();
    setState(() {
      _fcmToken = token;
    });
    print('FCM Token: $_fcmToken');

    // Foreground message handler
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');

      RemoteNotification? notification = message.notification;
      AndroidNotification? android = message.notification?.android;

      if (notification != null && android != null) {
        // Check if it's a call notification to show a specific UI/sound
        if (message.data['type'] == 'call') {
          NotificationService.showCallNotification(
            id: notification.hashCode,
            callerName: message.data['callerName'] ?? 'Unknown Caller',
            callType: message.data['callType'] ?? 'Incoming Call',
            callId: message.data['callId'] ?? 'no_call_id',
          );
        } else {
          // Show general notification
          NotificationService.showNotification(
            id: notification.hashCode,
            title: notification.title ?? 'No Title',
            body: notification.body ?? 'No Body',
            payload: message.data['payload'], // Pass custom payload
          );
        }
        NotificationService.incrementAndGetBadgeCount().then((count) {
          setState(() => _badgeCount = count);
        });
      }
    });

    // Handle interaction when app is opened from a notification (background/terminated)
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      print('A new onMessageOpenedApp event was published!');
      print('Message data: ${message.data}');

      // Clear badge count when app is opened from notification
      NotificationService.clearBadgeCount().then((_) {
        setState(() => _badgeCount = 0);
      });

      // Navigate based on payload
      if (message.data['type'] == 'call') {
        final callId = message.data['callId'];
        final callerName = message.data['callerName'];
        _router.go('/call?callId=$callId&callerName=$callerName');
      } else if (message.data['screen'] == 'history') {
        _router.go('/notification_history');
      }
      // Add more deep linking logic here
    });

    // Handle initial message when app is launched from a terminated state
    FirebaseMessaging.instance.getInitialMessage().then((RemoteMessage? message) {
      if (message != null) {
        print('App launched from terminated state via notification: ${message.data}');
        // Same deep linking logic as onMessageOpenedApp
        if (message.data['type'] == 'call') {
          final callId = message.data['callId'];
          final callerName = message.data['callerName'];
          _router.go('/call?callId=$callId&callerName=$callerName');
        } else if (message.data['screen'] == 'history') {
          _router.go('/notification_history');
        }
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      // key: MyApp.navigatorKey, // If using global key for navigation
      routerConfig: _router,
      title: 'Flutter FCM Calls',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      // Home page will display token and status
      // You can pass state to the HomePage using a builder if needed
      builder: (context, child) {
        return HomePage(
          fcmToken: _fcmToken,
          notificationStatus: _notificationStatus,
          badgeCount: _badgeCount,
          onClearBadge: () {
            NotificationService.clearBadgeCount().then((_) {
              setState(() => _badgeCount = 0);
            });
          },
        );
      },
    );
  }
}

// --- HOME PAGE WIDGET ---
class HomePage extends StatelessWidget {
  final String? fcmToken;
  final String notificationStatus;
  final int badgeCount;
  final VoidCallback onClearBadge;

  const HomePage({
    super.key,
    this.fcmToken,
    required this.notificationStatus,
    required this.badgeCount,
    required this.onClearBadge,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Flutter Call Notifications'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Firebase Cloud Messaging Status:',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text('Status: $notificationStatus'),
            const SizedBox(height: 8),
            const Text(
              'Your FCM Token (copy to send notifications):',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            SelectableText(
              fcmToken ?? 'Loading...',
              style: const TextStyle(fontSize: 12, fontFamily: 'monospace'),
            ),
            const SizedBox(height: 20),
            Text(
              'Current Badge Count: $badgeCount',
              style: const TextStyle(fontSize: 16),
            ),
            ElevatedButton(
              onPressed: onClearBadge,
              child: const Text('Clear Badge Count'),
            ),
            const SizedBox(height: 20),
            const Text(
              'Testing Buttons:',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                NotificationService.showNotification(
                  id: 0,
                  title: 'Test General Notification',
                  body: 'This is a test notification from the app.',
                  payload: 'app://general_info?id=test_notif',
                );
              },
              child: const Text('Show Test General Notification'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                NotificationService.showCallNotification(
                  id: 1,
                  callerName: 'Jane Doe',
                  callType: 'Video Call',
                  callId: 'test_call_123',
                );
              },
              child: const Text('Show Test Incoming Call Notification'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                context.go('/notification_history');
              },
              child: const Text('Go to Notification History'),
            ),
          ],
        ),
      ),
    );
  }
}

// --- CALL SCREEN WIDGET ---
class CallScreen extends StatelessWidget {
  final String? callId;
  final String? callerName;

  const CallScreen({super.key, this.callId, this.callerName});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Incoming Call'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.call, size: 100, color: Colors.green),
            const SizedBox(height: 20),
            Text(
              callerName != null ? '$callerName' : 'Unknown Caller',
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Text(
              callId != null ? 'Call ID: $callId' : 'No Call ID',
              style: const TextStyle(fontSize: 18, color: Colors.grey),
            ),
            const SizedBox(height: 30),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton.icon(
                  onPressed: () {
                    // Implement decline logic
                    Navigator.of(context).pop(); // Go back
                  },
                  icon: const Icon(Icons.call_end, color: Colors.white),
                  label: const Text('Decline'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                  ),
                ),
                ElevatedButton.icon(
                  onPressed: () {
                    // Implement answer logic
                    Navigator.of(context).pop(); // Go back
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Call Answered!')),
                    );
                  },
                  icon: const Icon(Icons.call, color: Colors.white),
                  label: const Text('Answer'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// --- NOTIFICATION HISTORY SCREEN WIDGET ---
class NotificationHistoryScreen extends StatelessWidget {
  const NotificationHistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Notification History'),
      ),
      body: const Center(
        child: Text('This screen would show past notifications.'),
      ),
    );
  }
}