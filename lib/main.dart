// lib/main.dart
import 'dart:typed_data';

import 'package:chat_app/screens/chat_message_service.dart';
import 'package:chat_app/screens/chat_screen.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';



// Import our Firebase options file (will be generated by FlutterFire CLI)
import 'firebase_options.dart';

// --- GLOBAL VARIABLES & TOP-LEVEL FUNCTIONS ---

// For local notifications
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

// Background message handler (MUST be a top-level function outside any class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Ensure Firebase is initialized for background messages
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  print('Handling a background message: ${message.messageId}');

  // Handle incoming call notifications
  if (message.data['type'] == 'call') {
    String callerName = message.data['callerName'] ?? 'Unknown Caller';
    String callType = message.data['callType'] ?? 'Incoming Call';
    String callId = message.data['callId'] ?? 'no_call_id';
    print('Received background call notification for ID: $callId from $callerName ($callType)');

    await NotificationService.showCallNotification(
      id: callId.hashCode,
      callerName: callerName,
      callType: callType,
      callId: callId,
    );
  }
  // Handle incoming chat messages
  else if (message.data['type'] == 'chat_message') {
    String senderName = message.data['senderName'] ?? 'Unknown';
    String messageContent = message.data['messageContent'] ?? 'No content';
    print('Received background chat message from $senderName: $messageContent');

    final newChatMessage = ChatMessage(
      sender: senderName,
      message: messageContent,
      timestamp: DateTime.now(),
    );
    await ChatMessageService.saveMessage(newChatMessage); // Save to local storage

    await NotificationService.showNotification( // Show a general notification
      id: newChatMessage.hashCode, // Unique ID for chat message notification
      title: 'New message from $senderName',
      body: messageContent,
      payload: 'app://chat', // Deep link to chat screen
    );
  }
}

// --- MAIN FUNCTION ---

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Set up background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize Flutter Local Notifications Plugin
  await NotificationService.initializeNotifications();

  runApp(const MyApp());
}

// --- NOTIFICATION SERVICE CLASS ---
// This class will encapsulate our notification logic for clarity

class NotificationService {
  static Future<void> initializeNotifications() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings(
      requestAlertPermission: false,
      requestBadgePermission: false,
      requestSoundPermission: false,
    );

    const InitializationSettings initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsIOS,
    );

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: onDidReceiveNotificationResponse,
      onDidReceiveBackgroundNotificationResponse: onDidReceiveNotificationResponse,
    );

    await createNotificationChannel();
  }

  static void onDidReceiveNotificationResponse(NotificationResponse response) {
    if (response.payload != null) {
      debugPrint('notification payload: ${response.payload}');
      final Uri uri = Uri.parse(response.payload!);
      
      // Handle call deep link
      if (uri.pathSegments.contains('call')) {
        String? callId = uri.queryParameters['callId'];
        print('Notification tapped: Navigating to call screen for $callId');
        // Use the global router instance to navigate
        MyApp.router.go('/call?callId=$callId&callerName=${uri.queryParameters['callerName']}');
      }
      // Handle chat deep link
      else if (uri.pathSegments.contains('chat')) {
        print('Notification tapped: Navigating to chat screen');
        MyApp.router.go('/chat');
      }
      // Handle general info deep link
      else if (uri.pathSegments.contains('general_info')) {
        print('Notification tapped: Navigating to general info');
        // Example: MyApp.router.go('/general_info');
      }
    }
  }

  static Future<void> createNotificationChannel() async {
    final AndroidNotificationChannel callChannel = AndroidNotificationChannel(
      'call_channel',
      'Incoming Calls',
      description: 'Notifications for incoming calls.',
      importance: Importance.max,
      playSound: true,
      sound: const RawResourceAndroidNotificationSound('ringtone'),
      enableVibration: true,
      vibrationPattern: Int64List.fromList(const [0, 1000, 500, 1000]),
      showBadge: true,
    );

    const AndroidNotificationChannel defaultChannel = AndroidNotificationChannel(
      'default_channel',
      'General Notifications',
      description: 'Notifications for general app updates.',
      importance: Importance.defaultImportance,
      showBadge: true,
    );

    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(callChannel);

    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(defaultChannel);
  }

  static Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'default_channel', // Use default channel for general messages
      'General Notifications',
      channelDescription: 'Notifications for general app updates.',
      importance: Importance.defaultImportance,
      priority: Priority.defaultPriority,
      showWhen: false,
      ticker: 'ticker',
    );
    const DarwinNotificationDetails iOSPlatformChannelSpecifics =
        DarwinNotificationDetails();
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );
    await flutterLocalNotificationsPlugin.show(
      id,
      title,
      body,
      platformChannelSpecifics,
      payload: payload,
    );
  }

  static Future<void> showCallNotification({
    required int id,
    required String callerName,
    required String callType,
    required String callId,
  }) async {
    final AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'call_channel',
      'Incoming Calls',
      channelDescription: 'Notifications for incoming calls.',
      importance: Importance.max,
      priority: Priority.max,
      fullScreenIntent: true,
      category: AndroidNotificationCategory.call,
      ongoing: true,
      autoCancel: false,
      color: Color(Colors.green.value),
      ticker: 'Incoming $callType from $callerName',
      largeIcon: const DrawableResourceAndroidBitmap('caller_avatar'),
    );

    const DarwinNotificationDetails iOSPlatformChannelSpecifics =
        DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
      interruptionLevel: InterruptionLevel.critical,
    );

    final NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );

    await flutterLocalNotificationsPlugin.show(
      id,
      callerName,
      'Incoming $callType',
      platformChannelSpecifics,
      payload: 'app://call?callId=$callId&callerName=$callerName',
    );
  }

  static Future<int> incrementAndGetBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    int count = (prefs.getInt('badge_count') ?? 0) + 1;
    await prefs.setInt('badge_count', count);
    
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(count); 
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(count); 
    return count;
  }

  static Future<void> clearBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('badge_count', 0);
    
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(0); 
    flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin>()
        ?.setAppBadgeCount(0); 
  }
}

extension on AndroidFlutterLocalNotificationsPlugin? {
  void setAppBadgeCount(int i) {}
}

extension on IOSFlutterLocalNotificationsPlugin? {
  void setAppBadgeCount(int i) {}
}

// --- APP WIDGETS ---

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  // Static getter for the GoRouter instance to allow navigation from static methods
  static late final GoRouter router;

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _fcmToken;
  String _notificationStatus = 'Initializing...';
  int _badgeCount = 0;

  @override
  void initState() {
    super.initState();
    // Initialize GoRouter here and assign to static variable
    MyApp.router = GoRouter(
      initialLocation: '/',
      routes: [
        GoRoute(
          path: '/',
          builder: (context, state) => HomePage(
            fcmToken: _fcmToken,
            notificationStatus: _notificationStatus,
            badgeCount: _badgeCount,
            onClearBadge: () {
              NotificationService.clearBadgeCount().then((_) {
                setState(() => _badgeCount = 0);
              });
            },
          ),
        ),
        GoRoute(
          path: '/call',
          builder: (context, state) {
            final callId = state.uri.queryParameters['callId'];
            final callerName = state.uri.queryParameters['callerName'];
            return CallScreen(callId: callId, callerName: callerName);
          },
        ),
        GoRoute(
          path: '/chat', // New chat route
          builder: (context, state) => const ChatScreen(),
        ),
        GoRoute(
          path: '/notification_history',
          builder: (context, state) => const NotificationHistoryScreen(),
        ),
      ],
      errorBuilder: (context, state) => Scaffold(
        appBar: AppBar(title: const Text('Error')),
        body: Center(child: Text('Page not found: ${state.error}')),
      ),
    );
    
    _initializeFirebaseMessaging();
    _loadBadgeCount();
  }

  Future<void> _loadBadgeCount() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _badgeCount = prefs.getInt('badge_count') ?? 0;
    });
  }

  void _initializeFirebaseMessaging() async {
    NotificationSettings settings = await FirebaseMessaging.instance.requestPermission(
      alert: true,
      announcement: true,
      badge: true,
      carPlay: false,
      criticalAlert: true,
      provisional: false,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      setState(() => _notificationStatus = 'Authorized');
      print('User granted permission');
    } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
      setState(() => _notificationStatus = 'Provisional');
      print('User granted provisional permission');
    } else {
      setState(() => _notificationStatus = 'Denied');
      print('User declined or has not accepted permission');
    }

    String? token = await FirebaseMessaging.instance.getToken();
    setState(() {
      _fcmToken = token;
    });
    print('FCM Token: $_fcmToken');

    // Foreground message handler
    FirebaseMessaging.onMessage.listen((RemoteMessage message) async { // Added async
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');

      RemoteNotification? notification = message.notification;
      AndroidNotification? android = message.notification?.android;

      // Handle incoming call notifications
      if (message.data['type'] == 'call') {
        if (notification != null && android != null) {
          NotificationService.showCallNotification(
            id: notification.hashCode,
            callerName: message.data['callerName'] ?? 'Unknown Caller',
            callType: message.data['callType'] ?? 'Incoming Call',
            callId: message.data['callId'] ?? 'no_call_id',
          );
        }
      }
      // Handle incoming chat messages
      else if (message.data['type'] == 'chat_message') {
        String senderName = message.data['senderName'] ?? 'Unknown';
        String messageContent = message.data['messageContent'] ?? 'No content';
        print('Received foreground chat message from $senderName: $messageContent');

        final newChatMessage = ChatMessage(
          sender: senderName,
          message: messageContent,
          timestamp: DateTime.now(),
        );
        await ChatMessageService.saveMessage(newChatMessage); // Save to local storage

        if (notification != null && android != null) {
          NotificationService.showNotification( // Show a general notification
            id: newChatMessage.hashCode,
            title: 'New message from $senderName',
            body: messageContent,
            payload: 'app://chat',
          );
        }
      }
      // Handle other general notifications
      else if (notification != null && android != null) {
        NotificationService.showNotification(
          id: notification.hashCode,
          title: notification.title ?? 'No Title',
          body: notification.body ?? 'No Body',
          payload: message.data['payload'],
        );
      }
      // Increment badge count for any foreground notification
      NotificationService.incrementAndGetBadgeCount().then((count) {
        setState(() => _badgeCount = count);
      });
    });

    // Handle interaction when app is opened from a notification (background/terminated)
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) async { // Added async
      print('A new onMessageOpenedApp event was published!');
      print('Message data: ${message.data}');

      // Clear badge count when app is opened from notification
      NotificationService.clearBadgeCount().then((_) {
        setState(() => _badgeCount = 0);
      });

      // Navigate based on payload
      if (message.data['type'] == 'call') {
        final callId = message.data['callId'];
        final callerName = message.data['callerName'];
        MyApp.router.go('/call?callId=$callId&callerName=$callerName');
      } else if (message.data['type'] == 'chat_message') {
        // Save message if it's a chat message and app opened from it
        String senderName = message.data['senderName'] ?? 'Unknown';
        String messageContent = message.data['messageContent'] ?? 'No content';
        final newChatMessage = ChatMessage(
          sender: senderName,
          message: messageContent,
          timestamp: DateTime.now(),
        );
        await ChatMessageService.saveMessage(newChatMessage); // Save to local storage
        MyApp.router.go('/chat'); // Navigate to chat screen
      } else if (message.data['screen'] == 'history') {
        MyApp.router.go('/notification_history');
      }
    });

    // Handle initial message when app is launched from a terminated state
    FirebaseMessaging.instance.getInitialMessage().then((RemoteMessage? message) async { // Added async
      if (message != null) {
        print('App launched from terminated state via notification: ${message.data}');
        // Clear badge count when app is opened from notification
        NotificationService.clearBadgeCount().then((_) {
          setState(() => _badgeCount = 0);
        });
        // Same deep linking logic as onMessageOpenedApp
        if (message.data['type'] == 'call') {
          final callId = message.data['callId'];
          final callerName = message.data['callerName'];
          MyApp.router.go('/call?callId=$callId&callerName=$callerName');
        } else if (message.data['type'] == 'chat_message') {
          // Save message if it's a chat message and app opened from it
          String senderName = message.data['senderName'] ?? 'Unknown';
          String messageContent = message.data['messageContent'] ?? 'No content';
          final newChatMessage = ChatMessage(
            sender: senderName,
            message: messageContent,
            timestamp: DateTime.now(),
          );
          await ChatMessageService.saveMessage(newChatMessage); // Save to local storage
          MyApp.router.go('/chat'); // Navigate to chat screen
        } else if (message.data['screen'] == 'history') {
          MyApp.router.go('/notification_history');
        }
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: MyApp.router, // Use the static router instance
      title: 'Flutter FCM Calls',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
    );
  }
}

// --- HOME PAGE WIDGET ---
class HomePage extends StatelessWidget {
  final String? fcmToken;
  final String notificationStatus;
  final int badgeCount;
  final VoidCallback onClearBadge;

  const HomePage({
    super.key,
    this.fcmToken,
    required this.notificationStatus,
    required this.badgeCount,
    required this.onClearBadge,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Flutter Call Notifications'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Firebase Cloud Messaging Status:',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text('Status: $notificationStatus'),
            const SizedBox(height: 8),
            const Text(
              'Your FCM Token (copy to send notifications):',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            SelectableText(
              fcmToken ?? 'Loading...',
              style: const TextStyle(fontSize: 12, fontFamily: 'monospace'),
            ),
            const SizedBox(height: 20),
            Text(
              'Current Badge Count: $badgeCount',
              style: const TextStyle(fontSize: 16),
            ),
            ElevatedButton(
              onPressed: onClearBadge,
              child: const Text('Clear Badge Count'),
            ),
            const SizedBox(height: 20),
            const Text(
              'Testing Buttons:',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                NotificationService.showNotification(
                  id: 0,
                  title: 'Test General Notification',
                  body: 'This is a test notification from the app.',
                  payload: 'app://general_info?id=test_notif',
                );
              },
              child: const Text('Show Test General Notification'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                NotificationService.showCallNotification(
                  id: 1,
                  callerName: 'Jane Doe',
                  callType: 'Video Call',
                  callId: 'test_call_123',
                );
              },
              child: const Text('Show Test Incoming Call Notification'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                context.go('/notification_history');
              },
              child: const Text('Go to Notification History'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              onPressed: () {
                context.go('/chat'); // New button to go to chat screen
              },
              child: const Text('Go to Chat Screen'),
            ),
          ],
        ),
      ),
    );
  }
}

// --- CALL SCREEN WIDGET ---
class CallScreen extends StatelessWidget {
  final String? callId;
  final String? callerName;

  const CallScreen({super.key, this.callId, this.callerName});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Incoming Call'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.call, size: 100, color: Colors.green),
            const SizedBox(height: 20),
            Text(
              callerName != null ? '$callerName' : 'Unknown Caller',
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Text(
              callId != null ? 'Call ID: $callId' : 'No Call ID',
              style: const TextStyle(fontSize: 18, color: Colors.grey),
            ),
            const SizedBox(height: 30),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton.icon(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  icon: const Icon(Icons.call_end, color: Colors.white),
                  label: const Text('Decline'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                  ),
                ),
                ElevatedButton.icon(
                  onPressed: () {
                    Navigator.of(context).pop();
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Call Answered!')),
                    );
                  },
                  icon: const Icon(Icons.call, color: Colors.white),
                  label: const Text('Answer'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// --- NOTIFICATION HISTORY SCREEN WIDGET ---
class NotificationHistoryScreen extends StatelessWidget {
  const NotificationHistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Notification History'),
      ),
      body: const Center(
        child: Text('This screen would show past notifications.'),
      ),
    );
  }
}